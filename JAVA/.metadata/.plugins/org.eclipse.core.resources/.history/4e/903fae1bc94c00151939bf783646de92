package model.matrix;

import java.util.ArrayList;
import java.util.Iterator;

import io.reader.MatrixReader;
import model.PairI;
import model.cluster.Clustering;
import model.facade.Facade;


/**
 * Allows to design our proper CSR + CSC format.
 *	<br>This storage format basically represents the original data twice, but only for performance requirements.
 *	Indeed, it allows to iterate easily and efficiently over rows and over columns, taking into account the matrix sparseness.
 *	<br>Furthermore, because CSR and CSC are very compressed formats, the gain still are huge :
 *	<br>-See : article{neelima2012effective,
  title={Effective Sparse Matrix Representation for the GPU Architectures},
  author={Neelima, B and Raghavendra, Prakash S},
  journal={International Journal of Computer Science, Engineering and Applications},
  volume={2},
  number={2},
  pages={151},
  year={2012},
  publisher={Academy and Industry Research Collaboration Center (AIRCC)}
}
<br>
	
	-See article{stanimirovic2009performance,
  title={Performance comparison of storage formats for sparse matrices},
  author={Stanimirovic, Ivan P and Tasic, Milan B},
  journal={FACTA UNIVERSITATIS (NIË‡S) Ser. Math. Inform},
  volume={24},
  pages={39--51},
  year={2009}
}<br>
 -See http://www.bu.edu/pasi/files/2011/01/NathanBell1-10-1000.pdf
 * 
 * @author dugue
 *
 *	
 *
 */
public class CsrMatrix {

	private ArrayList< PairI > rows;
	private ArrayList<Integer> cumulative_rows;
	
	private ArrayList<PairI> columns;
	private ArrayList<Integer> cumulative_columns;
	
	private Facade facade;
	
	public CsrMatrix(MatrixReader mr) {
		cumulative_rows=new ArrayList<Integer>(mr.getNb_rows());
		rows = new ArrayList<PairI>(mr.getNb_elmt());
		Iterator<ArrayList<PairI>> it_rows = mr.getMatrix_rows().iterator();
		Iterator<PairI> it_row;
		int row_i=0;
		int elmt_i=0;
		while (it_rows.hasNext()) {
			it_row=it_rows.next().iterator();
			while (it_row.hasNext()) {
				rows.add(it_row.next());
				elmt_i++;
			}
			cumulative_rows.add(elmt_i);
		}
		
		cumulative_columns=new ArrayList<Integer>(mr.getNb_columns());
		columns = new ArrayList<PairI>(mr.getNb_elmt());
		Iterator<ArrayList<PairI>> it_columns = mr.getMatrix_columns().iterator();
		Iterator<PairI> it_column;
		int column_i=0;
		elmt_i=0;
		while (it_columns.hasNext()) {
			it_column=it_columns.next().iterator();
			while (it_column.hasNext()) {
				columns.add(it_column.next());
				elmt_i++;
			}
			cumulative_columns.add(elmt_i);
		}
	}
	public CsrMatrix(MatrixReader mr, Clustering clustering) {
		this(mr);
		this.clustering = clustering;
	}
	

	public CsrMatrix() {
	}
	
	public int getCumulativeRows(int i) {
		return cumulative_rows.get(i);
	}
	public int getCumulativeColumns(int i) {
		return cumulative_columns.get(i);
	}
	
	public PairI getIinRows(int i) {
		return rows.get(i);
	}
	public PairI getIinColumns(int i) {
		return columns.get(i);
	}
	
	public int getNbElements() {
		return cumulative_rows.get(cumulative_rows.size() - 1);
	}
	public int getNbRows() {
		return cumulative_rows.size();
	}
	public int getNbColumns() {
		return cumulative_columns.size();
	}
	
	/**
	 * @param i the row you need to get the sum
	 * @return sum over the i-th row of the matrix
	 */
	public int getSumRow(int i) {
		return getSum(i, true, -1);		
	}
	
	/**
	 * @param i the column you need to get the sum
	 * @return sum over the i-th column of the matrix
	 */
	public int getSumCol(int i) {
		return getSum(i, false, -1);
	}
	/**
	 * @param i the column you need to get the sum
	 * @param k the cluster the rows have to belong to
	 * @return sum over the i-th column of the matrix for each objet that belongs to cluster k
	 */
	public int getSumColInCluster(int i, int k) {
		return getSum(i, false, k);
	}
	
	
	/**
	 * @param k the cluster you want to get the whole sum
	 * @return the sum over all the a_ij that belongs to the cluster
	 */
	public int getSumCluster(int k) {
		ArrayList<Integer> row_lists=clustering.getObjectsInCk(k);
		Iterator<Integer> it = row_lists.iterator();
		int sum=0;
		while (it.hasNext()) {
			sum+=getSumRow(it.next());
		}
		return sum;
	}
	
	private int getSum(int i, boolean is_on_row, int k) {
		ArrayList< PairI > rows_or_col;
		ArrayList<Integer> cumulative_rows_or_col;
		if (is_on_row) {
			rows_or_col=this.rows;
			cumulative_rows_or_col=this.cumulative_rows;
		}
		else {
			rows_or_col=this.columns;
			cumulative_rows_or_col=this.cumulative_columns;
		}
		int start;
		int end;
		if (i == 0) {
			start=0;
		}
		else {
			start=cumulative_rows_or_col.get(i-1);
		}
		end =cumulative_rows_or_col.get(i);
		int sum=0;
		for (int j=start; j < end; j++) {
			if ((k==-1) || (is_on_row) || (clustering == null) || (clustering.getClusterOfObjectI(rows_or_col.get(j).getLeft()) == k))
				sum +=rows_or_col.get(j).getRight();
		}
		return sum;
	}
	
	//Computes the feature recall
	private float fr(int column, int cluster) {
		//System.out.println("FR = " + getSumColInCluster(column, cluster)+ " / " + getSumCol(column));
		return (float)getSumColInCluster(column, cluster) / getSumCol(column);
	}
	
	// Computes the feature precision
	private float fp(int column, int cluster) {
		//System.out.println("FP = " + getSumColInCluster(column, cluster)+ " / " + getSumCluster(cluster));
		return (float)getSumColInCluster(column, cluster) / getSumCluster(cluster);
	}
	/**
	 * @param column the feature you are interested in as its column id
	 * @param cluster the cluster you are interested in as its id
	 * @return the feature F-measure of feature "column" in cluster "cluster"
	 */
	public float ff(int column, int cluster) {
		float fr=fr(column, cluster);
		float fp = fp(column, cluster);
		return (2*fr*fp/(fr+fp));
	}
	public int getNbCluster() {
		return clustering.size();
	}
	
}
